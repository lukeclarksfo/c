<!doctype html>
<html>
<head>

    <link rel="stylesheet" href="https://lukeclarksfo.github.io/header.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="cross-first-header">
    <div><a href="https://lukeclarksfo.github.io/">Luke Clark</a></div>
    <div><a href="https://github.com/lukeclarksfo/c/">GitHub</a></div>
</div>
<div id="cross-second-header">
    <h2>Algorithms and Data Structures in C</h2>
    <p>This contains algorithms written in C. Check out the repository to download and compile the programs.</p>
</div>

<main>
<h2>Algorithms and Data Structures in C</h2>

<h2>Sorting</h2>

<h3>Selection Sort</h3>
<p>One of the simplest sorting algorithms works as follows: first find
    the smallest element in the array and exchange it with the element in 
    the first position, then find the second smallest element and exchange
    it with the element in the second position, and continue in this way
    until the entire array is sorted. This method is called selection sort
    because it works by repeatedly "selecting" the smallest remaining element.
</p>

<pre>
    void selectionsort(int a[], int N)
    {
        int i, j, min, t;
        for(i = 1; i < N; i++)
        {
            min = i;
            for(j=i+1; i <= N; j++)
                if(a[j] < a[min]) min = j;
            t = a[min]; a[min] = a[i]; a[i] = t;
        }
    }
</pre>
<p>As the index i travels from left to right through the file, the elements 
    to the left of the index are in their final position in the array (and will not
    be touched again), so that the array is fully sorted when the index reaches the right end.
</p>
<p>This is among the simplest of sorting methods, and it will work very well for 
    small files. The "inner loop" is the compraison a[j]&lt;[amin] (plus the 
    code necessary to increment j and check that it does not exceed N), which
    could hardly be simpler.
</p>
<p>Despite its evident "brute-force" approach, selection sort actually has a
    quite important application: beacuse each item is actually moved at most once,
    selection sort is the method of choice for storing files with very large records
    and small keys.
</p>

<h3>Insertion Sort</h3>

<p>An algorithm almost as simple as selection sort but perhaps more flexible is
    insertion sort. The method proceeds as follows: consider the elements one at a time,
    inserting each in its proper place among those already considered (keeping them sorted).
    The element being considered is inserted merely by moving largeer elements one position
    to the right and then inserting the element into the vacated position.
</p>

<pre>
    void insertionsort(int a[], int N)
    {
        int i, j, v;
        for(i = 2; i <= N; i++)
        {
            v = a[i]; j = i;
            while(a[j-1] > v)
            {a[j]=a[j-1]; j--;}
            a[j] = v;
        }
    }
</pre>

<p>As in selection sort, the elements to the left of the index i are in sorted
    order during the sort, but they are not in their final position, as they may
    have to be moved to make room for smaller elements encountered later. However, the
    array is fully sorted when the index reaches the right end.
</p>

<p>There is one more important detail to consider: the procedure insertion doesn't work
    for most inputs! The while will run past the left end of the array when v is
    the smallest element in the array. To fix this, we put a "sentinel" key in
    a[0], making it at least as small as the smallest element in the array. Sentinels are 
    commonly used in situations like this to avoid including a test (in this case j>1)
    that almost always suceeds within the inner loop.
</p>

<h2>Bubble Sort</h2>

<p>An elementary sorting method that is often taught in introductory classes is bubble sort:
    keep passing through the file, exchanging adjacent elements, if necessary;
    when no exchanges are required on some pass, the file is sorted.
</p>

<pre>
    void bubblesort(int a[], int N)
    {
        int i, j t;
        for(i = N; i >= 1; i--)
            for(j=2; j <= i; j++)
                if(a[j-1] > a[j])
                {t = a[j-1]; a[j-1] = a[j]; a[j] = t;}
    }
</pre>

<p>It takes a moment's reflection to convince oneself that this works at all.
    To do so note that whenever the maximum element is encountered during
    the first pass, it is exchanged with each of the elements to its right,
    until it gets into position at the right end of the array. Then on the 
    second pass, the second largest element will be put into position, etc.
    Thus bubble sort operates as a type of selection sort, though it does
    much more work to get each element into position.
</p>

</main>
</body>
</html>